So the main inspiration was actually CSS. I've always loved the way it allows you to talk *about* groups of entities in a way that a) understands a concept of locality, and b) allows for independently cross-cutting sets through the use of classes.

Another inspiration was my early experience with jQuery. I *loved* the way state was all laid out flat (in HTML), again had locality, and you could watch it change and reason about what all was going on and what state you were in without tracing an object graph. Also, the selector-event listener-bubbling metaphor is a really fantastic way to describe mutations.

People readily - correctly - say that modern reactive UI frameworks are superior to jQuery. But they don't often think about why. The problem with jQuery isn't that it uses selectors and performs mutations; any stateful application has to have mutations. The problem with jQuery is that the UI *is* the state, rather than a function of the state. The way that HTML/jQuery/CSS actually represented, and mutated, and expounded upon state was *great*, it just needed to be decoupled from the actual rendered UI. We've now done that, but in React (an inevitable influence on my thinking) we've gone back to square one when it comes to state management. React Contexts took a partial step back in the direction of reasoning about subtrees rather than just direct children, but they're obtuse and clunky.

So, I started thinking about what it would look like if your whole application state was a tree of nested sets and primitives, with each object having a set of "types" as well, and optionally a locally-scoped name (global IDs aren't useful), which gives you something like named properties. Selectors can be used to talk about any subset of the state, objects can emit events which can be listened for and responded to in a hierarchical way. Pure functions can be passed any part of the world-space. The whole state (or any piece of it) is also trivially serializable and comparable, which is pretty neat.

There are three types of declarations: aspects, pure functions, and event listeners.

An aspect is like a CSS statement; a selector terminating in a specific named property of an object, and value that it's given. This isn't a mutation; it's a "default value" that objects of that type are assumed to have unless the actual state says otherwise. Purely declarative, and I plan to support specificity at some point.

A pure function is basically just that. It looks roughly like a JS arrow function, except it can't have multiple lines and can't have side-effects. There is one interesting caveat which may or may not work out well: since you're frequently passing around selected sets of unknown size, a function given sets for its arguments will permute all combinations of all the sets' elements and return the new set containing all of those return values. Again, that one may change after more experimentation. It's either a great idea or a terrible idea.

An event listener is roughly like one in jQuery; a selector followed by an event name and side-effects. Ah-hah! But functions can't have side-effects! Correct. An event listener doesn't take a function; all mutations are triggered by and take the form of events, and are rigidly distinct from functions (this is an idea I stole from Haskell). When you assign a value, that's one of the events triggered by another event listener. Event listeners can also be thought of as serving the role of methods; each is just a name, a subject, and arguments, so why make two separate constructs? This has the interesting implication that assignment operations themselves are observable events, which means you could select a subset of objects and then do something reactive when they are mutated. Another interesting implication is that the diamond problem doesn't exist; if there's a method signature conflict, you just do both things.

So what you end up with is state in the form of a tree, as well as a "computed" tree given all your aspects, and the ability to take pure functions of that.

Now, this language lends itself particularly well to a specific subset of cases, and not super well to many others. That subset is cases wherein state is structurally complex and interesting, and wherein state management is the primary programming challenge. Namely, UI's and games.

It's my current opinion that there are two reasons OOP ended up being bad:
1) Most problems being solved with code, especially in enterprise, do not match the above criteria and therefore don't really need a rich object ontology
2) The C++/Java paradigms were far too constraining. Reasoning about a subtree forced you to make a path through each level directly. Strict subsets prevented a lot of code-reuse. This is why in games especially, OOP seemed like it held more promise, but eventually gave way to composition-based paradigms like the ones in Unity and Unreal.

My goal is basically to create the language I'd like to use. I can imagine what it would be like to describe a world in Aspect (that's its name), and it seems poetic. Being able to talk about things in the abstract before talking about specific things. Really that's all I'm hoping to get; a language that's beautiful and expressive in a very unique way. Whether or not it ends up performant or even useful is secondary.